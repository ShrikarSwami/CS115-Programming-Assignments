#==============================================================================#
#                           CS 115 Lab 7 Report                             #
#==============================================================================#
+------------------------------------------------------------------------------+
| Fill in your name and the Stevens Honor Code pledge on the following lines.  |
| Failure to fill this in will result in deducted marks.                       |
+------------------------------------------------------------------------------+
Name: Shrikar Swami

Pledge: I pledge my honor that I have abided by the Stevens Honor System.

+------------------------------------------------------------------------------+
| If you have discussed this assignment with other students in the class, list |
| them below (write "None" if you worked alone). Additionally, list any        |
| additional resources you consulted.                                          |
+------------------------------------------------------------------------------+
Collaborators:

Sources:


-----------------------------------TASK 2---------------------------------------
+------------------------------------------------------------------------------+
| Task 2.1: What bits were printed?                                            |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
I encoded my_number = 42 as an int

The next was 2a 00 00 00

In bits it was 00101010 00000000 00000000 00000000

+------------------------------------------------------------------------------+
| Task 2.2 Is your system natively big-endian or little-endian? Describe how   |
| you figured that out.                                                        |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
My system is a little-endian, and I know this because I compared the native bits to the known references

So little <I: 2a 00 00 00
Then big >I: 00 00 00 2a
Native: 2a 00 00 00
Native matches the little endian reference, meaning my system placed the least significant bytes first

+------------------------------------------------------------------------------+
| Task 2.3 (using network byte order) What bits were printed?                   |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
Network hex 00 00 00 2a
Netwrok bits 00000000 00000000 00000000 00101010

+------------------------------------------------------------------------------+
| Task 2.4 Is the network encoding big-endian or     |
|   little-endian? Describe how you figured that out.                          |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
In python's struct and in networking standards, "network" means big-endian. So for my network bytes 00 00 00 2a match the big-ednain reference for 42


--------------------------------------------------------------------------------

-----------------------------------TASK 3---------------------------------------
+------------------------------------------------------------------------------+
| Task 3.1 Write an 8-bit representation of a number between 1 and 100 of      |
| your choice.                                                                 |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
I chose 67
8-but binary: 01000011

+------------------------------------------------------------------------------+
| Task 3.2 Write the negative of that number using 2's complement encoding.    |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
Inverting the bits:10111100
Add 1: 10111101
So the 8 but pattern for -67 is 10111101

+------------------------------------------------------------------------------+
| Task 3.3 Use pack_data to get the binary representation of that number as an |
| int.                                                                         |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
Bytes (hex): bd ff ff ff
Bytes (bits): 10111101 11111111 11111111 11111111

+------------------------------------------------------------------------------+
| Task 3.4 Compare the negative number you computed by hand to the result of   |
| packing the negative number as an int.                                       |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
My system is little endian, so the least significant byte is first.
LSB of packed -67 is 10111101, which matches my 8-but two's complement 10111101 which confirms that the twos complement on the byte level of my machine

+------------------------------------------------------------------------------+
| Optional Task 3: try encoding data using some of these types and inspect the |
| bytes. Note that not all data can be encoded with all types. Log anything    |
| you noticed that you found interesting.                                      | 
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
--------------------------------------------------------------------------------

-----------------------------------TASK 4---------------------------------------
+------------------------------------------------------------------------------+
| Task 4.1 Compare the result of packing 0.25 to -0.25 as a double as the      |
| number format. In particular, compare the sign bit(s), exponent (e) and      |
| mantissa (m).                                                                |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
Double +0.25
Hex: 3f d0 00 00 00 00 00 00
Bits: 00111111 11010000 00000000 00000000 00000000 00000000 00000000 00000000

Double âˆ’0.25
Hex: bf d0 00 00 00 00 00 00
Bits: 10111111 11010000 00000000 00000000 00000000 00000000 00000000 00000000

I noticed that the leading sig changes between + and -, but the exponent and mantissa fields are identical in both encodings

+------------------------------------------------------------------------------+
| Task 4.2 Compare double to float: how many bits are in each?                 |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
Double is 64 bits total, sign 1, exponent 11, mantissa 52
Float is 32 bits total, sign 1, exponent 8, mantissa 23

+------------------------------------------------------------------------------+
| Task 4.3 Why would Python language designers use a double to represent       |
| floating point numbers?                                                      |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
Using 64 bit doubles gives more precisoins and fewer rounding errors in typical programs, and aligns with standard C ABIs where python float maps to C double, this improves the numerical stability and portability
+------------------------------------------------------------------------------+
| Task 4 -- BONUS (optional) Does Python follow the IEEE 754 standard?         |
|                                                                              |
+------------------------------------------------------------------------------+
Put your answer here.
--------------------------------------------------------------------------------



-----------------------------------OVERALL--------------------------------------
+------------------------------------------------------------------------------+
| Did you encounter any problems while doing this assignment? If so, how did   |
| you resolve them?                                                            |
+------------------------------------------------------------------------------+
Put your answer here.
Just getting a start to be honest, once I did that it was kinda smooth sailing but definitely reviewing the material beforehand was not fun


+------------------------------------------------------------------------------+
| Do you have any additional comments about this assignment?                   |
+------------------------------------------------------------------------------+
Put your answer here.


